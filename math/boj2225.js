// 문제 : 합분해
// 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수 구하기 (각 경우의 수의 순열값 더하기)
// dfs -> 시간초과
// dp로 접근 -> 누적합

const solution = (n, k) => {
	const prefix = Array.from({ length: k + 1 }, () => Array.from({ length: n + 1 }).fill(0));

	for (let i = 0; i <= k; i++) {
		prefix[i][0] = 1;
	}

	for (let i = 1; i <= k; i++) {
		for (let j = 1; j <= n; j++) {
			prefix[i][j] = (prefix[i - 1][j] + prefix[i][j - 1]) % 1000000000;
		}
	}
	console.log(prefix[k][n]);
};

solution(20, 2);

/**
 * 

(n, k) => (4, 2) 예시
1 0 0 0 0
1 1 1 1 1
1 2 3 0 0

1 1 -> 1개의 수를 이용해서 1을 만드는 방법 : 1 0 (1 선택의 경우), 0 1 (0 선택의 경우)
2 1 -> 2개의 수를 이용해서 1을 만드는 방법 : 2 0 (1 선택의 경우), 1 1 (0 선택의 경우)
2 2 -> 2개의 수를 이용해서 2를 만드는 방법 : 2 1 (1 선택의 경우), 1 2 (0 선택의 경우)
2 3 -> 2개의 수를 이용해서 3을 만드는 방법 : 2 2 (1 선택의 경우), 1 3 (0 선택의 경우)

2개로 2를 만들고 1을 선택하거나,
1개로 3을 만들고 0을 선택하거나

...
k n -> k개의 수를 이용해서 n을 만드는 방법 : 현재 상태에서 내가 선택할 것은 0과 1중 하나
0을 선택할 때 : k개로 n을 만들어야 함
0을 선택할 때는 전체 합에 영향이 없으므로, 누적합 관점에서 선택한 수 1개를 뺀 후에 k-1개로 n을 만들어야 함
1 이상을 선택할 때 : 전체 합을 1(1을 선택했다면)을 줄이고, k개로 n-1을 만들어야 함
1 이상을 선택할 때는 전체 합에 영향이 있으므로, 누적합 관점에서 k개의 개수는 변하지 않음 -> 그냥 k개로 n-a를 구하는 경우의 수에 a를 더하면 되기 때문에


 */

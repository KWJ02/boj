// 하노이의 탑 이동 순서
/**
 * 재귀의 전체적인 흐름을 이해하려 하지 말고,
 * 과정을 최대한 간단히 생각해서
 * 1차적인 재귀만 구현한다 생각해야함
 
 * n개의 원판을 1기둥에서 3기둥으로 옮기는 작업을
 * 하나하나 생각하려하지말고
 * n-1개의 원판을 1기둥에서 2기둥으로,
 * 남은 1개의 원판을 1기둥에서 3기둥으로,
 * n-1개의 원판을 2기둥에서 3기둥으로 옮기는
 * 하나의 작업만을 생각하고 재귀를 구현하면, 나머지는 컴퓨터가 내부적으로 재귀로 해결
 */

/** */
const moves = [];

/**
 *
 * @param {*} n 원판 개수
 * @param {*} a 시작 기둥
 * @param {*} b 보조 기둥
 * @param {*} c 도착 기둥
 */
const hanoi = (n, a, b, c) => {
	if (n === 1) {
		moves.push(`${a} ${c}`); // n이 1이라면 출발점 -> 도착점 (재귀의 깊이에 따라 출발과 도착지점이 달라짐)
		return;
	}

	hanoi(n - 1, a, c, b); // n-1개를 출발 기둥에서 보조 기둥을 이용해 도착 기둥으로
	moves.push(`${a} ${c}`); // 출발 기둥에 남은 가장 큰 원판을 도착 기둥으로
	hanoi(n - 1, b, a, c); // 남은 n-1개를 보조 기둥에서 출발 기둥을 이용해 도착 기둥으로
};

hanoi(3, 1, 2, 3);
console.log(moves);
